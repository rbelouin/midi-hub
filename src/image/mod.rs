extern crate jpeg_decoder;

use std::convert::From;

mod image;
use image::Image;

mod scale;
use scale::scale;

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Error {
    JpegDecodingError,
    JpegInfoError,
    JpegPixelFormatError,
    HttpRequestError,
    HttpParseError,
    FileOpenError,
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub struct Pixel {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

impl From<&Pixel> for [u8; 3] {
    fn from(pixel: &Pixel) -> [u8; 3] {
        return [pixel.r, pixel.g, pixel.b];
    }
}

impl From<[u8; 3]> for Pixel {
    fn from(bytes: [u8; 3]) -> Pixel {
        return Pixel { r: bytes[0], g: bytes[1], b: bytes[2] };
    }
}

impl From<Image> for Vec<Pixel> {
    fn from(image: Image) -> Vec<Pixel> {
        let mut pixels = Vec::with_capacity(image.width * image.height);
        let mut pixel = Pixel { r: 0, g: 0, b: 0 };
        for n in 0..image.bytes.len() {
            match n % 3 {
                0 => { pixel.r = image.bytes[n]; },
                1 => { pixel.g = image.bytes[n]; },
                _ => {
                    pixel.b = image.bytes[n];
                    pixels.push(pixel.clone());
                },
            }
        }
        return pixels;
    }
}

pub async fn compress_from_url<A, F: FnOnce(&Image) -> Result<A, String>>(url: String, algo: F) -> Result<A, String> {
    let image = Image::from_url(&url).await.map_err(|err| format!("Error: {:?}", err))?;
    return algo(&image);
}

pub fn compress_8x8(image: &Image) -> Result<Vec<Pixel>, String> {
    return scale(image, 8, 8).map_err(|err| format!("Error: {:?}", err))
        .map(|image| Vec::from(image));
}

pub fn compress_1x1(image: &Image) -> Result<Pixel, String> {
    return scale(image, 1, 1).map_err(|err| format!("Error: {:?}", err))
        .map(|image| Vec::from(image)[0]);
}

#[cfg(test)]
mod tests {
    extern crate insta;
    extern crate jpeg_encoder;

    use std::file;
    use std::path::Path;

    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;
    use jpeg_encoder::{Encoder, ColorType};

    // This test relies on network calls, on Spotify’s CDN being up, and on the album cover not to
    // change. There’s a risk it becomes flaky, but I’ll keep it until the cost/benefit balance
    // becomes bad.
    #[test]
    fn test_compress_from_url() {
        let rt  =  tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            let url = "https://i.scdn.co/image/ab67616d00004851a5c51e96d2583bfb3e45d504".to_string();
            let result =  compress_from_url(url, compress_8x8).await;

            let encoder = Encoder::new_file(Path::new(file!()).with_file_name("test/cover-generated-small.jpg"), 100).unwrap();
            let data: Vec<u8> = result.as_ref().unwrap().iter().flat_map(|pixel| vec![pixel.r, pixel.g, pixel.b]).collect();
            let _ = encoder.encode(data.as_ref(), 8, 8, ColorType::Rgb);

            insta::assert_debug_snapshot!(result);
        });
    }

    /// test/random.jpg is a picture that has been generated by dividing a square into four equal
    /// areas with clear colors (red: 240,0,0; green: 0,240,0; blue: 0,0,240; yellow: 240,240,0)
    /// and adding some noise so that calculating the average color for each area should give us
    /// back the original value of the color.
    ///
    /// The reason why it consistently works with red, green, blue, but not yellow (notice that the
    /// bottom-right pixel is 240,239,0) is bugging me. Does JPEG hate yellow?
    #[test]
    fn test_load_random_image_and_scale_to_2x2() {
        let image = Image::from_path(Path::new(file!()).with_file_name("test/random.jpg")).expect("Expected test/random.jpg to be parsable");
        let scaled_image = scale(&image, 2, 2).expect("Expected the image to be scalable");

        assert_eq!(scaled_image, Image {
            width: 2,
            height: 2,
            bytes: vec![
                240,0,0,  0,240,0,
                0,0,240,  240,239,0,
            ],
        });
    }
}
