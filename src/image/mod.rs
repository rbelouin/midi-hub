extern crate jpeg_decoder;

mod image;
pub use image::Image;

mod scale;
pub use scale::scale;

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Error {
    JpegDecodingError,
    JpegInfoError,
    JpegPixelFormatError,
    HttpRequestError,
    HttpParseError,
    FileOpenError,
}

#[cfg(test)]
mod tests {
    extern crate insta;
    extern crate jpeg_encoder;

    use std::file;
    use std::path::Path;

    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;
    use jpeg_encoder::{Encoder, ColorType};

    // This test relies on network calls, on Spotify’s CDN being up, and on the album cover not to
    // change. There’s a risk it becomes flaky, but I’ll keep it until the cost/benefit balance
    // becomes bad.
    #[test]
    fn test_load_cover_from_url_and_scale_to_8x8() {
        let rt  =  tokio::runtime::Runtime::new().unwrap();
        rt.block_on(async {
            let url = "https://i.scdn.co/image/ab67616d00004851a5c51e96d2583bfb3e45d504".to_string();
            let image = Image::from_url(&url).await.expect("Expected the image to be downloadable");
            let scaled_image = scale(&image, 8, 8).expect("Expected the image to be scalable");

            let encoder = Encoder::new_file(Path::new(file!()).with_file_name("test/cover-generated-small.jpg"), 100).unwrap();
            let _ = encoder.encode(&scaled_image.bytes, scaled_image.width as u16, scaled_image.height as u16, ColorType::Rgb);

            insta::assert_debug_snapshot!(scaled_image);
        });
    }

    /// test/random.jpg is a picture that has been generated by dividing a square into four equal
    /// areas with clear colors (red: 240,0,0; green: 0,240,0; blue: 0,0,240; yellow: 240,240,0)
    /// and adding some noise so that calculating the average color for each area should give us
    /// back the original value of the color.
    ///
    /// The reason why it consistently works with red, green, blue, but not yellow (notice that the
    /// bottom-right pixel is 240,239,0) is bugging me. Does JPEG hate yellow?
    #[test]
    fn test_load_random_image_and_scale_to_2x2() {
        let image = Image::from_path(Path::new(file!()).with_file_name("test/random.jpg")).expect("Expected test/random.jpg to be parsable");
        let scaled_image = scale(&image, 2, 2).expect("Expected the image to be scalable");

        assert_eq!(scaled_image, Image {
            width: 2,
            height: 2,
            bytes: vec![
                240,0,0,  0,240,0,
                0,0,240,  240,239,0,
            ],
        });
    }
}
